// Generated by CoffeeScript 2.3.2
(function () {
  var TallinnPollClient, col_names, https, numberToTypeMap;

  https = require('https');
  request = require('request');

  col_names = ['type', 'lineNumber', 'longitude', 'latitude', 'speed', 'heading', 'vehicleNumber'];

  numberToTypeMap = {
    '1': 'subway',
    '2': 'bus',
    '3': 'tram'
  };

  TallinnPollClient = class TallinnPollClient {
    constructor(callback, args, otpUrl) {
      this.callback = callback;
      this.args = args;
      this.routes = {
        "": {}
      };
      this.poll_delay = 5;
      this.otpUrl = otpUrl;
    }

    set_poll_timer(route_name, is_error) {
      var delay, route, timeout_handler;
      route = this.routes[route_name];
      if (route.timeout) {
        clearTimeout(route.timeout);
      }
      timeout_handler = () => {
        route.timeout = null;
        return this.poll_route(route_name);
      };
      if (is_error) {
        delay = this.poll_delay * 10;
      } else {
        delay = this.poll_delay;
      }
      delay *= 1000;
      return route.timeout = setTimeout(timeout_handler, delay);
    }

    getRouteGtfsIdFromOTP(info, updateLoc) {
      if (parseInt(info.lineNumber) === 0) {
        return;
      }
      info.type = numberToTypeMap[info.type];
      var bodyJson = {json: {query: '{ routes ( name: "' + info.lineNumber + '", modes: "' + info.type.toUpperCase() + '" ) { shortName gtfsId mode  } }'}};

      request.post(this.otpUrl, bodyJson, (error, res, body) => {
        var self = this;
        if (error) {
          console.error(error);
          return
        } else if (!body.data) {
          return;
        }
        var routes = body.data.routes;
        if (routes.length > 0) {
          let otpRoutes = routes.filter(function (route) {
            return (route.shortName === info.lineNumber) && (route.mode === info.type.toUpperCase());
          });

          otpRoutes.forEach((route) => {
            const tempInfo = {...info, gtfsId: route.gtfsId};
            updateLoc(tempInfo, self);
          });
        }
      });

    }

    update_location(info, self) {
      const date = new Date();
      var out_info, path, route, vehicle_id, latitude, longitude;

      latitude = info.latitude.substring(0, 2) + "." + info.latitude.substring(2, info.latitude.length);
      longitude = info.longitude.substring(0, 2) + "." + info.longitude.substring(2, info.longitude.length);

      out_info = {
        vehicle: {
          id: info.vehicleNumber,
          label: info.type + info.vehicleNumber,
          type: info.type
        },
        trip: {
          gtfsId: info.gtfsId.split(':')[1],
          route: info.lineNumber,
          direction: 0,
          operator: "Tallinna TA",
          headsign: info.lineNumber,
          start_time: ("0" + date.getHours()).slice(-2) + ":" + ("0" + date.getMinutes()).slice(-2)
        },
        position: {
          latitude: parseFloat(latitude),
          longitude: parseFloat(longitude),
          //                odometer: parseFloat info.distance_from_start
          speed: (parseFloat(info.speed)) / 3.6,
          bearing: info.heading
        },
        //                delay: -(parseFloat info.difference_from_timetable)
        timestamp: new Date().getTime() / 1000
      };
      // Create path/channel that is used for publishing the out_info for the
      // interested navigator-proto clients via the @callback function
      route = info.route;
      vehicle_id = out_info.vehicle.id.replace(" ", "_");
      path = `/location/tallinn/${route}/${vehicle_id}`;
      return self.callback(path, out_info, self.args);
    }

    poll_route() {
      var opts, route;
      route = this.routes[""];
      opts = {
        host: 'transport.tallinn.ee',
        path: "/gps.txt"
      };
      route.req = https.get(opts, (resp) => {
        var data;
        data = '';
        route.req = null;
        resp.on('data', (chunk) => {
          return data += chunk;
        });
        return resp.on('end', (chunk) => {
          var cols, i, idx, info, j, len, len1, line, lines, n;
          if (resp.statusCode !== 200) {
            console.log(`request failed: code ${resp.statusCode}`);
            this.set_poll_timer("", true);
            return;
          }
          lines = data.split(/\r?\n/);
          for (i = 0, len = lines.length; i < len; i++) {
            line = lines[i];
            cols = line.split(',');
            info = {};
            for (idx = j = 0, len1 = col_names.length; j < len1; idx = ++j) {
              n = col_names[idx];
              info[n] = cols[idx];
            }
            if (!info.lineNumber) {
              continue;
            }
            this.getRouteGtfsIdFromOTP(info, this.update_location);
          }
          return this.set_poll_timer("", false);
        });
      });
      return route.req.on('error', (e) => {
        console.log("polling failed: " + e.message);
        route.req = null;
        return this.set_poll_timer("", true);
      });
    }

    connect() {
      return this.poll_route();
    }

  };

  module.exports.TallinnPollClient = TallinnPollClient;

}).call(this);
  
